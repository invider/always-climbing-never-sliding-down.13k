<!DOCTYPE html>
<html>
    <head>
        <title>Liminal</title>

        <style>
            * {
                margin: 0;
                padding: 0;
            }
            body {
                overflow: hidden;
                background-color: #000000;
            }
            canvas {
                border: 0px;
                position: absolute;
                display: block;
            }
        </style>

        <script id="v-shader" type="x-shader/x-vertex">
            uniform mat4 mMatrix;
            uniform mat4 nMatrix;
            uniform mat4 vMatrix;
            uniform mat4 pMatrix;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            //attribute vec3 aVertexColor;

            varying vec3 vPosition;
            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec3 vWorldNormal;
            varying vec3 vCamNormal;

            void main(void) {
                vPosition = aVertexPosition;
                vWorldPosition = (mMatrix * vec4(aVertexPosition, 1.0)).xyz;
                vNormal = aVertexNormal;
                vWorldNormal = (nMatrix * vec4(aVertexNormal, 1.0)).xyz;
                vCamNormal = (vMatrix * mMatrix * vec4(aVertexNormal, 1.0)).xyz;

                /*
                // DEBUG hardcode for now
                // setup lights
                vec3 ambientLight = vec3(.2, .2, .2);
                //vec3 diffuseLightColor = vec3(.5, .5, .8);
                //vec3 directionalLightPosition = normalize( vec3(1, 1, 1) );
                vec3 pointLightPosition = vec3(5.0, 5.0, 3.0);
                vec3 pointLightDirection = normalize(
                    vec3(pointLightPosition.xyz - aVertexPosition.xyz));
                vec3 l = normalize( vec3(pMatrix * vMatrix * mMatrix * vec4(pointLightDirection, 1.0)) );
                vec3 n = normalize( nMatrix * aVertexNormal)
                */
                //float diffuseLightFactor = max( dot(worldNormal, directionalLightPosition), 0.0 );
                //vLight = ambientLight + (diffuseLightColor * diffuseLightFactor);

                gl_Position = pMatrix * vMatrix * mMatrix * vec4(aVertexPosition, 1.0);
            }
        </script>

        <script id="f-shader" type="x-shader/x-fragment">
            precision mediump float;

            // matrices
            uniform highp mat4 mMatrix;
            uniform highp mat4 nMatrix;
            uniform highp mat4 vMatrix;
            uniform highp mat4 pMatrix;

            // environment
            uniform highp vec3 uDirectionalLightVector;
            uniform highp vec4 uDirectionalLightColorI;
            uniform highp vec3 uPointLightPosition;
            uniform highp vec4 uPointLightColorI;

            // material
            uniform highp vec3 uAmbientColor;
            uniform highp vec3 uDiffuseColor;
            uniform highp vec3 uSpecularColor;
            uniform highp vec3 uEmissionColor;

            uniform highp vec4 uLightIntensities;
            uniform highp float uShininess;

            varying vec3 vPosition;
            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec3 vWorldNormal;
            varying vec3 vCamNormal;

            void main(void) {
                // DEBUG material props
                highp float opacity = 1.0;
                highp float roughness = 1.0;
                // <<<--- must be set by uniforms

                highp vec3 normal = normalize(vNormal);
                highp vec3 worldNormal = normalize(vWorldNormal);

                // just take it from the vertex shader
                //highp vec3 lWorldNormal = (nMatrix * vec4(normal, 0)).xyz;

                // TODO expand into a 3-component vector with dir light colors included
                highp float diffuseDirectionalLambert = max(
                    dot(worldNormal, uDirectionalLightVector),
                    0.0
                ) * uDirectionalLightColorI.w;

                // do one point light
                highp vec3 pointLightDirection = normalize(uPointLightPosition - vWorldPosition);
                highp float diffusePointLambert = max(
                    dot(worldNormal, pointLightDirection),
                    0.0
                ) * uPointLightColorI.w;

                // mix directional and point lights factors
                highp float diffuseLambert = diffuseDirectionalLambert + diffusePointLambert;

                // specular
                highp mat4 pvm = pMatrix * vMatrix * mMatrix;
                highp mat4 vm = vMatrix * mMatrix;
                
                /*
                highp vec3 vtxCamPos = vec3( vm * vec4(vPosition, 1.0) );
                highp vec3 camPointLightPos = vec3( vMatrix * vec4(uPointLightPosition, 1.0) );
                highp vec3 toLight = normalize(camPointLightPos - vtxCamPos); // ??? light -> cam coords?
                highp vec3 toCam = normalize(-vtxCamPos); // V

                // R
                highp vec3 reflection = normalize( 2.0
                    * dot(normalize(vCamNormal), toLight) * normalize(vCamNormal) - toLight
                );
                highp float specular = pow(
                    max( dot(reflection, toCam), 0.0 ), 100.0//uShininess
                ) * uPointLightColorI.w;
                */

                highp vec3 sPointLightDirection = normalize(uPointLightPosition - vPosition);
                highp vec3 l = normalize( vec3(pvm * vec4(sPointLightDirection, 1.0)) );
                highp vec3 n = normalize( vec3(nMatrix * vec4( normalize(vNormal), 1.0)) );
                highp vec3 v = normalize( -vec3(pvm * vec4(vPosition, 1.0)) );
                highp vec3 r = reflect(l, n);

                highp float specular = pow( max(0.0, dot(r, v)), uShininess) * uPointLightColorI.w;

                /*
                highp vec3 l = normalize( vec3(mvp * vec4(pointLightDirection, 1.0)) );
                highp vec3 v = normalize( -vec3(mvp * vec4(vPosition, 1.0)) );

                highp vec3 n = normalize( vec3( nMatrix * vec4(vNormal, 0) ));
                //highp vec3 n = normalize( vec3( nMatrix * vec4(vNormal, 0) ) );
                //highp mat4 imMatrix = transpose(inverse(mMatrix));
                //highp vec3 n = normalize( vec3( imMatrix * vec4(vNormal), 0) );

                //highp float diffuseLambert = dot(l, n);
                highp float diffuseLambert = max(
                    dot(vWorldNormal, normalize(directionalLightPosition)), 0.0 );

                */

                gl_FragColor = vec4(
                    uAmbientColor * uLightIntensities.x
                    + uDiffuseColor * diffuseLambert * uLightIntensities.y
                    + uSpecularColor * specular * uLightIntensities.z,
                    opacity);
            }
        </script>

        <script src="js/math.js"></script>
        <script src="js/util.js"></script>
        <script src="js/geo.js"></script>

        <script src="js/dna/Frame.js"></script>
        <script src="js/dna/Camera.js"></script>
        <script src="js/dna/Cube.js"></script>
        <script src="js/dna/Mesh.js"></script>

        <script src="js/env.js"></script>
        <script src="js/trap.js"></script>
        <script src="js/setup.js"></script>
        <script src="js/scene.js"></script>
        <script src="js/cycle.js"></script>

        <script src="box/box1.js"></script>
    </head>

    <body>
        <canvas id="canvas"></canvas>
        <canvas id="hcanvas"></canvas>
    </body>
</html>
